---
// Carica i dati dal file JSON locale
import galleryData from "../data/pixar_archivio.json";
import "../styles/gallery3d.css";

// Generate random color for placeholder
function getRandomColor(seed: number): string {
	const colors = [
		"#FF6B6B",
		"#4ECDC4",
		"#45B7D1",
		"#FFA07A",
		"#98D8C8",
		"#F7DC6F",
		"#BB8FCE",
		"#85C1E2",
		"#F8B195",
		"#6C5CE7",
		"#A8E6CF",
		"#FFD3B6",
		"#FFAAA5",
		"#FF8B94",
		"#C7CEEA",
	];
	return colors[seed % colors.length];
}

// Prepara i dati con percorsi ottimizzati per WebP
const processedData = galleryData.map((item, index) => {
	const raw: any = item;
	const personaggio = raw["Personaggio/soggetto"] || "";
	const film = raw["Film/corto"] || "";
	const anno = raw.Anno || "";
	const innovazione = raw["Nome Innovazione"] || "";
	const category = raw["Categoria Innovazione (tag)"] || "";

	// Prefer `Copertina` if present, otherwise fall back to first ImgXX
	let src = raw.Copertina || "";
	if (!src) {
		for (let i = 1; i <= 10; i++) {
			const key = `Img${String(i).padStart(2, "0")}`;
			if (raw[key]) {
				src = raw[key];
				break;
			}
		}
	}

	const extPattern = new RegExp("\\.(jpg|jpeg|png|webp|avif)$", "i");
	const filename = src ? src.split("/").pop() || "" : "";
	const nameWithoutExt = filename.replace(extPattern, "");

	// Generate placeholder color if no image
	const placeholderColor = !src ? getRandomColor(index) : null;

	return {
		ID: raw.ID ?? index + 1,
		PERSONAGGIO: personaggio,
		FILM: film,
		ANNO: anno,
		INNOVAZIONE: innovazione,
		CATEGORY: category,
		SRC: src,
		optimizedSrc: nameWithoutExt ? `/images/${nameWithoutExt}.webp` : "",
		placeholderColor: placeholderColor,
		raw: raw,
	};
});
---

<div id="canvas-container" data-gallery={JSON.stringify(processedData)}></div>
<div id="image-info">
	<div id="image-personaggio"></div>
	<div class="image-details">
		<div id="image-film"></div>
		<div id="image-innovazione"></div>
		<div id="image-anno"></div>
	</div>
</div>

<script>
	import * as THREE from "three";

	// Setup scena
	const scene = new THREE.Scene();
	// Gestione background rimossa dallo script: verrÃ  definita via CSS.
	// Renderizziamo la canvas con alpha:true (vedi renderer) per permettere
	// allo sfondo CSS di essere visibile attraverso la canvas.

	// Camera isometrica
	const aspect = window.innerWidth / window.innerHeight;
	const frustumSize = 10;
	const camera = new THREE.OrthographicCamera(
		(frustumSize * aspect) / -2,
		(frustumSize * aspect) / 2,
		frustumSize / 2,
		frustumSize / -2,
		0.1,
		1000
	);

	// Posizionamento camera per vista isometrica
	camera.position.set(12, 10, 10);
	camera.lookAt(0, 0, 0);

	// Renderer
	const container = document.getElementById("canvas-container");
	// Abilitiamo alpha:true cosÃ¬ la canvas Ã¨ trasparente e lascia vedere
	// lo sfondo definito dal CSS del `#canvas-container`.
	const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setPixelRatio(window.devicePixelRatio);
	container?.appendChild(renderer.domElement);

	// Array per le immagini
	const images: THREE.Mesh[] = [];
	const imageData: {
		mesh: THREE.Mesh;
		originalY: number;
		targetY: number;
		currentY: number;
		originalX: number;
		currentX: number;
		originalZ: number;
		currentZ: number;
		delay: number;
	}[] = [];

	// TextureLoader
	const textureLoader = new THREE.TextureLoader();

	// Variabili per animazione iniziale
	let isInitialAnimationComplete = false;
	const initialAnimationStartTime = Date.now();

	// Funzione per creare le immagini dalla sorgente dati
	async function loadImages() {
		try {
			// Leggi i dati pre-caricati dal server
			const container = document.getElementById("canvas-container");
			const galleryDataStr = container?.getAttribute("data-gallery");

			if (!galleryDataStr) {
				console.error("Nessun dato trovato");
				return;
			}

			const data = JSON.parse(galleryDataStr);
			const numImages = data.length;
			const spacing = 0.4;

			console.log(
				`Caricamento di ${numImages} immagini da dati pre-caricati...`
			);

			// Crea le immagini
			data.forEach((item: any, i: number) => {
				// Geometria rettangolare per l'immagine
				const geometry = new THREE.PlaneGeometry(2, 1.5);

				let material: THREE.MeshBasicMaterial;

				if (item.optimizedSrc || item.SRC) {
					// Carica direttamente la texture
					const texture = textureLoader.load(
						item.optimizedSrc || item.SRC,
						// onLoad callback
						loadedTexture => {
							console.log(`âœ… Immagine caricata: ${item.NAME}`);
							// Ottimizzazioni texture
							loadedTexture.minFilter = THREE.LinearFilter;
							loadedTexture.magFilter = THREE.LinearFilter;
							loadedTexture.generateMipmaps = false;
						},
						// onProgress callback
						undefined,
						// onError callback
						error => {
							console.error(`âŒ Errore caricamento ${item.NAME}: ${item.SRC}`);
						}
					);
					// Material con texture
					material = new THREE.MeshBasicMaterial({ map: texture });
				} else if (item.placeholderColor) {
					// Material con colore piatto se nessuna immagine
					console.log(`ðŸŽ¨ Placeholder colore per: ${item.NAME}`);
					material = new THREE.MeshBasicMaterial({
						color: item.placeholderColor,
					});
				} else {
					// Fallback grigio
					material = new THREE.MeshBasicMaterial({ color: "#CCCCCC" });
				}
				const mesh = new THREE.Mesh(geometry, material);

				// Posizionamento finale con variazioni casuali
				const finalX = (Math.random() - 0.02) * 0.02;
				const finalY = -0.2 + (Math.random() - 0.02) * 0.01;
				const finalZ =
					(i - (numImages - 1) / 2) * spacing + (Math.random() - 0.2) * 0.08;

				// Posizione iniziale (leggero spostamento in alto a destra)
				const startX = finalX + 0.1;
				const startY = finalY + 0.2;
				const startZ = finalZ + 0.1;

				mesh.position.set(startX, startY, startZ);

				// Imposta opacity iniziale a 0
				material.transparent = true;
				material.opacity = 0;

				// Aggiungi metadata per riferimento
				mesh.userData = {
					id: item.ID,
					personaggio: item.PERSONAGGIO,
					film: item.FILM,
					anno: item.ANNO,
					innovazione: item.INNOVAZIONE,
				};

				scene.add(mesh);
				images.push(mesh);

				// Delay scaglionato per effetto cascata
				const delay = i * 40; // 40ms tra ogni immagine

				imageData.push({
					mesh: mesh,
					originalY: finalY,
					targetY: finalY,
					currentY: startY,
					originalX: finalX,
					currentX: startX,
					originalZ: finalZ,
					currentZ: startZ,
					delay: delay,
				});
			});
		} catch (error) {
			console.error("Errore nel fetch dei dati:", error);
		}
	}

	// Carica le immagini
	loadImages();

	// Raycaster per il hover
	const raycaster = new THREE.Raycaster();
	const mouse = new THREE.Vector2();
	let hoveredImage: THREE.Mesh | null = null;

	// Elemento per mostrare le info
	const titleElement = document.getElementById("image-info");
	const personaggioElement = document.getElementById("image-personaggio");
	const filmElement = document.getElementById("image-film");
	const innovazioneElement = document.getElementById("image-innovazione");
	const annoElement = document.getElementById("image-anno");

	// Event listener per il mouse
	window.addEventListener("mousemove", event => {
		mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

		raycaster.setFromCamera(mouse, camera);
		const intersects = raycaster.intersectObjects(images);

		// Dispatch custom event per il cursore personalizzato
		const isHovering = intersects.length > 0;
		window.dispatchEvent(
			new CustomEvent("3d-hover", { detail: { isHovering } })
		);

		// Mostra/nascondi le info
		if (intersects.length > 0 && titleElement) {
			const hoveredMesh = intersects[0].object as THREE.Mesh;
			if (personaggioElement)
				personaggioElement.textContent = hoveredMesh.userData.personaggio;
			if (filmElement)
				filmElement.textContent = `Film: ${hoveredMesh.userData.film}`;
			if (innovazioneElement)
				innovazioneElement.textContent = `Innovazione: ${hoveredMesh.userData.innovazione}`;
			if (annoElement)
				annoElement.textContent = `Anno: ${hoveredMesh.userData.anno}`;
			titleElement.classList.add("visible");
		} else if (titleElement) {
			titleElement.classList.remove("visible");
		}

		// Prima resetta tutte le immagini
		imageData.forEach(data => {
			data.targetY = data.originalY;
		});

		// Poi crea l'effetto onda
		hoveredImage = null;
		if (intersects.length > 0) {
			hoveredImage = intersects[0].object as THREE.Mesh;
			const hoveredIndex = images.indexOf(hoveredImage);

			if (hoveredIndex !== -1) {
				// Parametri per l'effetto onda
				const maxLift = 1;
				const waveRange = 1;

				// Applica l'effetto a tutte le immagini nell'intervallo
				for (let i = 0; i < imageData.length; i++) {
					const distance = Math.abs(i - hoveredIndex);

					if (distance <= waveRange) {
						const influence = 1 - distance / waveRange;
						const lift = maxLift * Math.pow(influence, 2);

						imageData[i].targetY = imageData[i].originalY + lift;
					}
				}
			}
		}
	});

	// Variabile per controllare lo stato dell'animazione
	let isAnimating = false;

	// Event listener per il click
	window.addEventListener("click", event => {
		if (isAnimating) return; // Previene click multipli durante l'animazione

		mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

		raycaster.setFromCamera(mouse, camera);
		const intersects = raycaster.intersectObjects(images);

		if (intersects.length > 0) {
			isAnimating = true;
			const clickedMesh = intersects[0].object as THREE.Mesh;
			const filmId = clickedMesh.userData.id;

			// Nascondi le info
			if (titleElement) {
				titleElement.classList.remove("visible");
			}

			// Avvia l'animazione
			animateTransition(clickedMesh, filmId);
		}
	});

	// Funzione per animare la transizione
	function animateTransition(selectedMesh: THREE.Mesh, filmId: string) {
		const duration = 1200; // Durata totale in ms
		const fadeOutDuration = 100; // Durata fade out altre immagini (piÃ¹ veloce)
		const transitionDuration = 700; // Durata transizione isometrica->2D (piÃ¹ veloce)
		const startTime = Date.now();

		// Imposta tutte le altre immagini come trasparenti immediatamente
		images.forEach(mesh => {
			if (mesh !== selectedMesh) {
				const material = mesh.material as THREE.MeshBasicMaterial;
				material.transparent = true;
			}
		});

		// Posizione iniziale della camera
		const initialCameraPos = camera.position.clone();
		const initialCameraTarget = new THREE.Vector3(0, 0, 0);

		// Posizione finale della camera (frontale)
		const finalCameraPos = new THREE.Vector3(
			selectedMesh.position.x,
			selectedMesh.position.y,
			selectedMesh.position.z + 5
		);
		const finalCameraTarget = selectedMesh.position.clone();

		// Posizione e scala iniziale dell'immagine selezionata
		const initialPos = selectedMesh.position.clone();
		const initialScale = selectedMesh.scale.clone();
		const finalScale = new THREE.Vector3(1.5, 1.5, 1.5); // Scala piÃ¹ grande

		function updateTransition() {
			const elapsed = Date.now() - startTime;
			const progress = Math.min(elapsed / duration, 1);

			// Easing function per fade (ease-out quartico)
			const easeFade = (t: number) => 1 - Math.pow(1 - t, 4);

			// Easing function per transizione (ease-out cubico - veloce ma fluido)
			const easeTransition = (t: number) => 1 - Math.pow(1 - t, 3);

			// Fase 1: Fade out delle altre immagini
			if (elapsed <= fadeOutDuration) {
				const fadeProgress = easeFade(elapsed / fadeOutDuration);
				images.forEach(mesh => {
					if (mesh !== selectedMesh) {
						const material = mesh.material as THREE.MeshBasicMaterial;
						material.opacity = 1 - fadeProgress;
					}
				});
			} else {
				// Nascondi completamente le altre immagini
				images.forEach(mesh => {
					if (mesh !== selectedMesh) {
						mesh.visible = false;
					}
				});
			}

			// Fase 2: Transizione camera e immagine veloce e fluida
			if (elapsed > 100) {
				const transitionProgress = Math.min(
					(elapsed - 100) / transitionDuration,
					1
				);
				const easeValue = easeTransition(transitionProgress);

				// Interpola posizione camera
				camera.position.lerpVectors(
					initialCameraPos,
					finalCameraPos,
					easeValue
				);

				// Interpola target camera
				const currentTarget = new THREE.Vector3();
				currentTarget.lerpVectors(
					initialCameraTarget,
					finalCameraTarget,
					easeValue
				);
				camera.lookAt(currentTarget);

				// Scala l'immagine selezionata
				selectedMesh.scale.lerpVectors(initialScale, finalScale, easeValue);

				// Centra l'immagine
				const centerPos = new THREE.Vector3(0, 0, selectedMesh.position.z);
				selectedMesh.position.lerpVectors(initialPos, centerPos, easeValue);
			}

			// Continua l'animazione o naviga alla pagina
			if (progress < 1) {
				requestAnimationFrame(updateTransition);
			} else {
				// Animazione completata, naviga alla pagina
				console.log(`Navigazione a film/${filmId}`);
				window.location.href = `/film/${filmId}`;
			}
		}

		updateTransition();
	}

	// Gestione resize
	window.addEventListener("resize", () => {
		const aspect = window.innerWidth / window.innerHeight;
		camera.left = (frustumSize * aspect) / -2;
		camera.right = (frustumSize * aspect) / 2;
		camera.top = frustumSize / 2;
		camera.bottom = frustumSize / -2;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	});

	// Animation loop
	function animate() {
		requestAnimationFrame(animate);

		// Animazione iniziale di caricamento
		if (!isInitialAnimationComplete) {
			const elapsed = Date.now() - initialAnimationStartTime;
			const animationDuration = 800; // Durata animazione per ogni immagine
			let allComplete = true;

			imageData.forEach(data => {
				const imageElapsed = elapsed - data.delay;

				if (imageElapsed > 0) {
					const progress = Math.min(imageElapsed / animationDuration, 1);

					// Easing function (ease-out cubic per movimento fluido)
					const easeProgress = 1 - Math.pow(1 - progress, 3);

					// Interpola posizioni con movimento leggero
					data.currentX =
						data.currentX + (data.originalX - data.currentX) * 0.08;
					data.currentY =
						data.currentY + (data.originalY - data.currentY) * 0.08;
					data.currentZ =
						data.currentZ + (data.originalZ - data.currentZ) * 0.08;

					data.mesh.position.set(data.currentX, data.currentY, data.currentZ);

					// Fade-in dell'opacity
					const material = data.mesh.material as THREE.MeshBasicMaterial;
					const targetOpacity = 1;
					material.opacity =
						material.opacity + (targetOpacity - material.opacity) * 0.08;

					// Controlla se questa immagine ha completato l'animazione
					const threshold = 0.01;
					if (
						Math.abs(data.currentX - data.originalX) > threshold ||
						Math.abs(data.currentY - data.originalY) > threshold ||
						Math.abs(data.currentZ - data.originalZ) > threshold ||
						Math.abs(material.opacity - targetOpacity) > 0.01
					) {
						allComplete = false;
					}
				} else {
					allComplete = false;
				}
			});

			if (allComplete) {
				isInitialAnimationComplete = true;
				// Imposta le posizioni e opacity finali esatte
				imageData.forEach(data => {
					data.currentX = data.originalX;
					data.currentY = data.originalY;
					data.currentZ = data.originalZ;
					data.mesh.position.set(
						data.originalX,
						data.originalY,
						data.originalZ
					);
					const material = data.mesh.material as THREE.MeshBasicMaterial;
					material.opacity = 1;
				});
			}
		} else {
			// Animazione smooth per l'hover (solo dopo l'animazione iniziale)
			imageData.forEach(data => {
				const diff = data.targetY - data.currentY;
				data.currentY += diff * 0.1;
				data.mesh.position.y = data.currentY;
			});
		}

		renderer.render(scene, camera);
	}

	animate();
</script>
